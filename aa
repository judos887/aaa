pcall(function()
    for _, v in ipairs(game.CoreGui:GetChildren()) do
        if v.Name == "SchmecktPvP" then v:Destroy() end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer

local PlayerModule = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
local Controls = PlayerModule:GetControls()

local SaveFileName = "SchmecktPvP_Settings.json"
local AllConnections = {}
local AllKeybinds = {}
local ListeningForKeybind = nil

local URLS = {
    AutoGrab = "https://raw.githubusercontent.com/ima123-en/auto-grab/refs/heads/main/ag"
}

local function TrackConnection(conn)
    table.insert(AllConnections, conn)
    return conn
end

local function CleanupAllConnections()
    for _, conn in ipairs(AllConnections) do
        pcall(function() conn:Disconnect() end)
    end
    AllConnections = {}
end

local function LoadSettings()
    local success, result = pcall(function()
        if readfile then
            return HttpService:JSONDecode(readfile(SaveFileName))
        end
    end)
    if success and result then return result end
    return {}
end

local function SaveSettings(settings)
    pcall(function()
        if writefile then
            writefile(SaveFileName, HttpService:JSONEncode(settings))
        end
    end)
end

local SavedSettings = LoadSettings()
local ScaleFactor = 1
local SelectedVersion = nil

local WalkFlingRunning = false
local FlingConnection = nil
local CollisionConnection = nil

local AntiRagdollActive = false
local AntiRagdollConnections = {}

local AntiKnockbackActive = false
local AntiKnockbackConnection = nil
local HitboxConnection = nil
local IsJumping = false

local MaxHorizontalSpeed = 60
local MaxVerticalKnockback = 50

local FloatStealEnabled = false
local FloatPlatform = nil
local FloatConnection = nil
local IsCurrentlyFloating = false
local FloatStealStartTime = 0
local OriginalGroundY = nil

local FloatHeight = 13
local FloatHeightNearBase = 11
local BaseProximityRange = 20
local SmartFloatRange = 30
local FloatStartDelay = 0.5

local SpeedBoostEnabled = false
local NormalSpeed = SavedSettings.NormalSpeed or 57
local StealSpeed = SavedSettings.StealSpeed or 29.5

-- Tween Speed Boost Variables (NEW SYSTEM)
local TweenSpeedEnabled = false
local TweenTargetSpeed = 61
local TweenLerpAlpha = 0.35
local TweenRampSpeed = 0.08
local TweenCurrentMultiplier = 0
local TweenLastPosition = nil
local TweenLastTime = 0
local TweenCorrectionCount = 0

local AutoBatEnabled = false
local BatSpamDelay = 0.05

local UnwalkEnabled = false
local UnwalkConnections = {}

local TargetPlayerEnabled = false
local TargetPlayerConn = nil

local InfJumpEnabled = false
local InfJumpConn = nil
local InfFallConn = nil
local JumpForce = 50
local ClampFallSpeed = 80

local XrayEnabled = false
local XrayActive = false
local OriginalTransparency = {}

local AutoGrabEnabled = false

local lastVelocity = Vector3.new(0, 0, 0)

local SetWalkFling, SetTweenPanel, SetUnwalk, SetTargetPlayer, SetInfJump, SetXray, SetAutoGrab
local GetWalkFling, GetTweenPanel, GetFloatSteal, GetSpeedBoost, GetHitboxExp, GetAutoBat, GetAntiRagdoll, GetAntiKnockback, GetUnwalk, GetTargetPlayer, GetInfJump, GetXray, GetAutoGrab
local ScreenGui, SpeedFrame, SpeedStatusLabel

-- Tween Speed Boost Functions (from first script)
local function IsGroundedTween(hrp)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -3.5, 0), rayParams)
    return result ~= nil
end

local function DetectCorrectionTween(hrp)
    local now = tick()
    local currentPos = hrp.Position
    
    if TweenLastPosition and (now - TweenLastTime) > 0 then
        local expected = (now - TweenLastTime) * TweenTargetSpeed * TweenCurrentMultiplier
        local actual = (Vector3.new(currentPos.X, 0, currentPos.Z) - Vector3.new(TweenLastPosition.X, 0, TweenLastPosition.Z)).Magnitude
        
        if expected > 2 and actual < expected * 0.5 then
            TweenCorrectionCount = TweenCorrectionCount + 1
            TweenLastPosition = currentPos
            TweenLastTime = now
            return true
        end
    end
    
    TweenLastPosition = currentPos
    TweenLastTime = now
    return false
end

local function ApplyTweenSpeed(hrp, moveDir)
    if moveDir.Magnitude < 0.1 then 
        TweenCurrentMultiplier = 0.3
        return 0
    end
    
    local corrected = DetectCorrectionTween(hrp)
    
    if corrected then
        TweenCurrentMultiplier = 0.5
    else
        TweenCurrentMultiplier = math.min(1, TweenCurrentMultiplier + TweenRampSpeed)
        TweenCorrectionCount = math.max(0, TweenCorrectionCount - 0.05)
    end
    
    local safeSpeed = TweenTargetSpeed
    if TweenCorrectionCount > 3 then
        safeSpeed = TweenTargetSpeed * 0.8
    elseif TweenCorrectionCount > 1 then
        safeSpeed = TweenTargetSpeed * 0.9
    end
    
    local finalSpeed = safeSpeed * TweenCurrentMultiplier
    local grounded = IsGroundedTween(hrp)
    local alpha = grounded and TweenLerpAlpha or (TweenLerpAlpha * 0.5)
    
    local currentVel = hrp.AssemblyLinearVelocity
    local targetVel = moveDir.Unit * finalSpeed
    local newVel = Vector3.new(
        currentVel.X + (targetVel.X - currentVel.X) * alpha,
        currentVel.Y,
        currentVel.Z + (targetVel.Z - currentVel.Z) * alpha
    )
    
    hrp.AssemblyLinearVelocity = newVel
    
    return math.floor(Vector3.new(newVel.X, 0, newVel.Z).Magnitude)
end

local function ResetTweenSpeed()
    TweenCurrentMultiplier = 0.3
    TweenCorrectionCount = 0
    TweenLastPosition = nil
    TweenLastTime = 0
end

-- Export for Tween Panel to use
getgenv().SchmecktTweenSpeed = {
    Apply = ApplyTweenSpeed,
    Reset = ResetTweenSpeed,
    GetCorrectionCount = function() return TweenCorrectionCount end,
    SetEnabled = function(val) TweenSpeedEnabled = val end,
    IsEnabled = function() return TweenSpeedEnabled end
}

local function GetMyPlot()
    local plots = Workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in pairs(plots:GetChildren()) do
        for _, obj in pairs(plot:GetDescendants()) do
            if obj:IsA("TextLabel") and obj.Text then
                if obj.Text:find(LocalPlayer.Name) or obj.Text:find(LocalPlayer.DisplayName) then
                    return plot
                end
            end
        end
    end
    return nil
end

local function GetMyAnimalTarget()
    local myPlot = GetMyPlot()
    if not myPlot then return nil end
    local animalTarget = myPlot:FindFirstChild("AnimalTarget")
    if animalTarget and animalTarget:IsA("BasePart") then
        return animalTarget.Position
    end
    return nil
end

local function GetDistanceToBase(hrp)
    local basePos = GetMyAnimalTarget()
    if not basePos then return math.huge end
    return (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - Vector3.new(basePos.X, 0, basePos.Z)).Magnitude
end

local function GetRealGroundY(hrp)
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    local filterList = {LocalPlayer.Character}
    if FloatPlatform then table.insert(filterList, FloatPlatform) end
    rayParams.FilterDescendantsInstances = filterList
    local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -200, 0), rayParams)
    if result then
        return result.Position.Y
    end
    return hrp.Position.Y - 3
end

local function GetCurrentFloatHeight(hrp)
    local distToBase = GetDistanceToBase(hrp)
    if distToBase <= BaseProximityRange then
        return FloatHeightNearBase
    end
    return FloatHeight
end

local function DisableAnimations()
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if animator then
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end
        animator:Destroy()
    end
    local animate = character:FindFirstChild("Animate")
    if animate then
        animate:Destroy()
    end
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("Animation") or desc:IsA("AnimationTrack") then
            pcall(function() desc:Destroy() end)
        end
    end
end

local function EnableUnwalk()
    if UnwalkEnabled then return end
    UnwalkEnabled = true
    DisableAnimations()
    local charAddedConn = LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        if UnwalkEnabled then
            DisableAnimations()
        end
    end)
    table.insert(UnwalkConnections, charAddedConn)
end

local function DisableUnwalk()
    UnwalkEnabled = false
    for _, conn in pairs(UnwalkConnections) do
        pcall(function() conn:Disconnect() end)
    end
    UnwalkConnections = {}
end

local function findBat()
    local c = LocalPlayer.Character
    if not c then return nil end
    local bp = LocalPlayer:FindFirstChildOfClass("Backpack")
    local SlapList = {"Bat","Slap","Iron Slap","Gold Slap","Diamond Slap","Emerald Slap","Ruby Slap","Dark Matter Slap","Flame Slap","Nuclear Slap","Galaxy Slap","Glitched Slap"}
    for _, ch in ipairs(c:GetChildren()) do
        if ch:IsA("Tool") and ch.Name:lower():find("bat") then return ch end
    end
    if bp then
        for _, ch in ipairs(bp:GetChildren()) do
            if ch:IsA("Tool") and ch.Name:lower():find("bat") then return ch end
        end
    end
    for _, name in ipairs(SlapList) do
        local t = c:FindFirstChild(name) or (bp and bp:FindFirstChild(name))
        if t then return t end
    end
    return nil
end

local function findNearestEnemy()
    local c = LocalPlayer.Character
    if not c then return nil, nil, nil end
    local myHRP = c:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil, nil, nil end
    local nearest, nearestDist, nearestTorso = nil, math.huge, nil
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local eh = p.Character:FindFirstChild("HumanoidRootPart")
            local torso = p.Character:FindFirstChild("UpperTorso") or p.Character:FindFirstChild("Torso")
            local hum = p.Character:FindFirstChildOfClass("Humanoid")
            if eh and hum and hum.Health > 0 then
                local d = (eh.Position - myHRP.Position).Magnitude
                if d < nearestDist then nearestDist = d; nearest = eh; nearestTorso = torso or eh end
            end
        end
    end
    return nearest, nearestDist, nearestTorso
end

local function StartTargetPlayer()
    if TargetPlayerConn then return end
    TargetPlayerConn = RunService.Heartbeat:Connect(function()
        if not TargetPlayerEnabled then return end
        local c = LocalPlayer.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end
        local bat = findBat()
        if bat and bat.Parent ~= c then pcall(function() hum:EquipTool(bat) end) end
        local target, _, torso = findNearestEnemy()
        if target and torso then
            local dir = torso.Position - h.Position
            local flatDir = Vector3.new(dir.X, 0, dir.Z)
            if flatDir.Magnitude > 1.5 then
                local moveDir = flatDir.Unit
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X*55, h.AssemblyLinearVelocity.Y, moveDir.Z*55)
            else
                local tv = target.AssemblyLinearVelocity
                h.AssemblyLinearVelocity = Vector3.new(tv.X, h.AssemblyLinearVelocity.Y, tv.Z)
            end
            if bat then pcall(function() bat:Activate() end) end
        end
    end)
end

local function StopTargetPlayer()
    if TargetPlayerConn then TargetPlayerConn:Disconnect(); TargetPlayerConn = nil end
end

local function EnableInfJump()
    if InfJumpConn then InfJumpConn:Disconnect(); InfJumpConn = nil end
    if InfFallConn then InfFallConn:Disconnect(); InfFallConn = nil end
    if not InfJumpEnabled then return end
    InfFallConn = RunService.Heartbeat:Connect(function()
        if not InfJumpEnabled then return end
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root and root.AssemblyLinearVelocity.Y < -ClampFallSpeed then
            root.AssemblyLinearVelocity = Vector3.new(root.AssemblyLinearVelocity.X, -ClampFallSpeed, root.AssemblyLinearVelocity.Z)
        end
    end)
    InfJumpConn = UserInputService.JumpRequest:Connect(function()
        if not InfJumpEnabled then return end
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            root.AssemblyLinearVelocity = Vector3.new(root.AssemblyLinearVelocity.X, JumpForce, root.AssemblyLinearVelocity.Z)
        end
    end)
end

local function DisableInfJump()
    if InfJumpConn then InfJumpConn:Disconnect(); InfJumpConn = nil end
    if InfFallConn then InfFallConn:Disconnect(); InfFallConn = nil end
end

local function EnableXray()
    if getgenv and getgenv().OPTIMIZER_ACTIVE then return end
    if getgenv then getgenv().OPTIMIZER_ACTIVE = true end
    pcall(function()
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        Lighting.GlobalShadows = false; Lighting.Brightness = 3; Lighting.FogEnd = 9e9
    end)
    pcall(function()
        for _, obj in ipairs(Workspace:GetDescendants()) do
            pcall(function()
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then obj:Destroy() end
                if obj:IsA("BasePart") then obj.CastShadow = false; obj.Material = Enum.Material.Plastic end
            end)
        end
    end)
    XrayActive = true
    pcall(function()
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Anchored and (obj.Name:lower():find("base") or (obj.Parent and obj.Parent.Name:lower():find("base"))) then
                OriginalTransparency[obj] = obj.LocalTransparencyModifier
                obj.LocalTransparencyModifier = 0.85
            end
        end
    end)
end

local function DisableXray()
    if getgenv then getgenv().OPTIMIZER_ACTIVE = false end
    if XrayActive then
        for part, val in pairs(OriginalTransparency) do
            if part then part.LocalTransparencyModifier = val end
        end
        OriginalTransparency = {}; XrayActive = false
    end
end

local function ShowVersionSelector()
    local SelectorGui = Instance.new("ScreenGui")
    SelectorGui.Name = "SchmecktVersionSelector"
    SelectorGui.ResetOnSpawn = false
    SelectorGui.Parent = game.CoreGui

    local SelectorFrame = Instance.new("Frame")
    SelectorFrame.Size = UDim2.new(0, 300, 0, 150)
    SelectorFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
    SelectorFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    SelectorFrame.BorderSizePixel = 0
    SelectorFrame.Parent = SelectorGui
    Instance.new("UICorner", SelectorFrame).CornerRadius = UDim.new(0, 10)
    Instance.new("UIStroke", SelectorFrame).Color = Color3.fromRGB(138, 43, 226)

    local TitleLabel = Instance.new("TextLabel")
    TitleLabel.Size = UDim2.new(1, 0, 0, 40)
    TitleLabel.Position = UDim2.new(0, 0, 0, 10)
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Text = "Select Version"
    TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TitleLabel.Font = Enum.Font.GothamBold
    TitleLabel.TextSize = 20
    TitleLabel.Parent = SelectorFrame

    local PCButton = Instance.new("TextButton")
    PCButton.Size = UDim2.new(0, 120, 0, 50)
    PCButton.Position = UDim2.new(0, 25, 0, 70)
    PCButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    PCButton.Text = "PC Version"
    PCButton.TextColor3 = Color3.fromRGB(180, 100, 255)
    PCButton.Font = Enum.Font.GothamBold
    PCButton.TextSize = 16
    PCButton.Parent = SelectorFrame
    Instance.new("UICorner", PCButton).CornerRadius = UDim.new(0, 8)
    Instance.new("UIStroke", PCButton).Color = Color3.fromRGB(138, 43, 226)

    local MobileButton = Instance.new("TextButton")
    MobileButton.Size = UDim2.new(0, 120, 0, 50)
    MobileButton.Position = UDim2.new(0, 155, 0, 70)
    MobileButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    MobileButton.Text = "Mobile Version"
    MobileButton.TextColor3 = Color3.fromRGB(180, 100, 255)
    MobileButton.Font = Enum.Font.GothamBold
    MobileButton.TextSize = 16
    MobileButton.Parent = SelectorFrame
    Instance.new("UICorner", MobileButton).CornerRadius = UDim.new(0, 8)
    Instance.new("UIStroke", MobileButton).Color = Color3.fromRGB(138, 43, 226)

    local Selected = false

    PCButton.MouseButton1Click:Connect(function()
        if Selected then return end
        Selected = true
        ScaleFactor = 1
        SelectedVersion = "PC"
        SelectorGui:Destroy()
    end)

    MobileButton.MouseButton1Click:Connect(function()
        if Selected then return end
        Selected = true
        ScaleFactor = 1 / 2.3
        SelectedVersion = "Mobile"
        SelectorGui:Destroy()
    end)

    repeat task.wait() until SelectedVersion ~= nil
end

ShowVersionSelector()

ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "SchmecktPvP"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.CoreGui

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 280 * ScaleFactor, 0, 560 * ScaleFactor)
MainFrame.Position = UDim2.new(1, -300 * ScaleFactor, 0, 120 * ScaleFactor)
MainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.Parent = ScreenGui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 8 * ScaleFactor)
Instance.new("UIStroke", MainFrame).Color = Color3.fromRGB(138, 43, 226)

local TopBar = Instance.new("Frame")
TopBar.Size = UDim2.new(1, 0, 0, 32 * ScaleFactor)
TopBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
TopBar.BorderSizePixel = 0
TopBar.Parent = MainFrame
Instance.new("UICorner", TopBar).CornerRadius = UDim.new(0, 8 * ScaleFactor)
Instance.new("UIStroke", TopBar).Color = Color3.fromRGB(138, 43, 226)

local Title = Instance.new("TextLabel")
Title.Text = "Schmeckt PvP | .gg/schmeckt"
Title.Font = Enum.Font.GothamBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 13 * ScaleFactor
Title.BackgroundTransparency = 1
Title.Size = UDim2.new(1, -40 * ScaleFactor, 1, 0)
Title.Position = UDim2.new(0, 10 * ScaleFactor, 0, 0)
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TopBar

local CloseButton = Instance.new("TextButton")
CloseButton.Text = "X"
CloseButton.Font = Enum.Font.GothamBold
CloseButton.TextSize = 16 * ScaleFactor
CloseButton.TextColor3 = Color3.fromRGB(255, 60, 60)
CloseButton.BackgroundTransparency = 1
CloseButton.Size = UDim2.new(0, 30 * ScaleFactor, 0, 30 * ScaleFactor)
CloseButton.Position = UDim2.new(1, -32 * ScaleFactor, 0, 1 * ScaleFactor)
CloseButton.Parent = TopBar

local function CreateToggle(parent, text, yPos, settingKey, defaultState, forceDefault)
    local Container = Instance.new("Frame", parent)
    Container.Size = UDim2.new(1, -20 * ScaleFactor, 0, 38 * ScaleFactor)
    Container.Position = UDim2.new(0, 10 * ScaleFactor, 0, yPos * ScaleFactor)
    Container.BackgroundTransparency = 1

    local Label = Instance.new("TextLabel", Container)
    Label.Text = text
    Label.Font = Enum.Font.GothamBold
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.TextSize = 12 * ScaleFactor
    Label.BackgroundTransparency = 1
    Label.Size = UDim2.new(0, 100 * ScaleFactor, 1, 0)
    Label.TextXAlignment = Enum.TextXAlignment.Left

    local KeybindBox = Instance.new("TextButton", Container)
    KeybindBox.Size = UDim2.new(0, 50 * ScaleFactor, 0, 18 * ScaleFactor)
    KeybindBox.Position = UDim2.new(0, 105 * ScaleFactor, 0.5, -9 * ScaleFactor)
    KeybindBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    KeybindBox.BorderSizePixel = 0
    KeybindBox.Text = ""
    KeybindBox.TextColor3 = Color3.fromRGB(180, 100, 255)
    KeybindBox.TextSize = 10 * ScaleFactor
    KeybindBox.Font = Enum.Font.GothamBold
    KeybindBox.AutoButtonColor = false
    Instance.new("UICorner", KeybindBox).CornerRadius = UDim.new(0, 4 * ScaleFactor)
    local kbStroke = Instance.new("UIStroke", KeybindBox)
    kbStroke.Color = Color3.fromRGB(60, 60, 60)
    kbStroke.Thickness = 1

    local keybindKey = settingKey and (settingKey .. "_Keybind") or nil
    if keybindKey and SavedSettings[keybindKey] then
        KeybindBox.Text = SavedSettings[keybindKey]
    end

    local SwitchBg = Instance.new("Frame", Container)
    SwitchBg.Size = UDim2.new(0, 36 * ScaleFactor, 0, 18 * ScaleFactor)
    SwitchBg.Position = UDim2.new(1, -46 * ScaleFactor, 0.5, -9 * ScaleFactor)
    SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Instance.new("UICorner", SwitchBg).CornerRadius = UDim.new(1, 0)

    local Knob = Instance.new("Frame", SwitchBg)
    Knob.Size = UDim2.new(0, 14 * ScaleFactor, 0, 14 * ScaleFactor)
    Knob.Position = UDim2.new(0, 2 * ScaleFactor, 0.5, -7 * ScaleFactor)
    Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)

    local Separator = Instance.new("Frame", parent)
    Separator.Size = UDim2.new(1, -20 * ScaleFactor, 0, 1 * ScaleFactor)
    Separator.Position = UDim2.new(0, 10 * ScaleFactor, 0, (yPos + 38) * ScaleFactor)
    Separator.BackgroundColor3 = Color3.fromRGB(138, 43, 226)

    local toggled
    if forceDefault then
        toggled = defaultState or false
    else
        toggled = (settingKey and SavedSettings[settingKey] ~= nil) and SavedSettings[settingKey] or defaultState or false
    end

    local function updateVisual()
        if toggled then
            Knob.Position = UDim2.new(1, -16 * ScaleFactor, 0.5, -7 * ScaleFactor)
            Knob.BackgroundColor3 = Color3.fromRGB(180, 100, 255)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(100, 50, 150)
        else
            Knob.Position = UDim2.new(0, 2 * ScaleFactor, 0.5, -7 * ScaleFactor)
            Knob.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
            SwitchBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end

    local function setToggle(state)
        toggled = state
        updateVisual()
        if settingKey and not forceDefault then
            SavedSettings[settingKey] = toggled
            SaveSettings(SavedSettings)
        end
    end

    updateVisual()

    SwitchBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            setToggle(not toggled)
        end
    end)

    KeybindBox.MouseButton1Click:Connect(function()
        if ListeningForKeybind then
            ListeningForKeybind.box.Text = ListeningForKeybind.original or ""
            ListeningForKeybind.box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        end
        ListeningForKeybind = {
            box = KeybindBox,
            original = KeybindBox.Text,
            settingKey = keybindKey,
            setToggle = setToggle,
            getToggle = function() return toggled end
        }
        KeybindBox.Text = "..."
        KeybindBox.BackgroundColor3 = Color3.fromRGB(80, 50, 0)
    end)

    if keybindKey then
        AllKeybinds[keybindKey] = {
            box = KeybindBox,
            setToggle = setToggle,
            getToggle = function() return toggled end
        }
    end

    return function() return toggled end, setToggle
end

TrackConnection(UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

    if ListeningForKeybind then
        local keyName = input.KeyCode.Name
        if input.KeyCode == Enum.KeyCode.Escape then
            ListeningForKeybind.box.Text = ListeningForKeybind.original or ""
            ListeningForKeybind.box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            ListeningForKeybind = nil
            return
        end
        if input.KeyCode == Enum.KeyCode.Backspace or input.KeyCode == Enum.KeyCode.Delete then
            ListeningForKeybind.box.Text = ""
            ListeningForKeybind.box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            if ListeningForKeybind.settingKey then
                SavedSettings[ListeningForKeybind.settingKey] = nil
                SaveSettings(SavedSettings)
            end
            ListeningForKeybind = nil
            return
        end
        ListeningForKeybind.box.Text = keyName
        ListeningForKeybind.box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        if ListeningForKeybind.settingKey then
            SavedSettings[ListeningForKeybind.settingKey] = keyName
            SaveSettings(SavedSettings)
        end
        ListeningForKeybind = nil
        return
    end

    for keybindKey, data in pairs(AllKeybinds) do
        local savedKey = SavedSettings[keybindKey]
        if savedKey and savedKey ~= "" then
            if input.KeyCode.Name == savedKey then
                data.setToggle(not data.getToggle())
            end
        end
    end
end))

local GetAntiRagdollFunc, SetAntiRagdoll = CreateToggle(MainFrame, "Anti Ragdoll", 42, "AntiRagdoll", false)
GetAntiRagdoll = GetAntiRagdollFunc
local GetAntiKnockbackFunc, SetAntiKnockback = CreateToggle(MainFrame, "Anti Knockback", 82, "AntiKnockback", false)
GetAntiKnockback = GetAntiKnockbackFunc
local GetWalkFlingFunc, SetWalkFlingFunc = CreateToggle(MainFrame, "WalkFling", 122, "WalkFling", false)
GetWalkFling = GetWalkFlingFunc
SetWalkFling = SetWalkFlingFunc
local GetAutoGrabFunc, SetAutoGrabFunc = CreateToggle(MainFrame, "Auto Grab", 162, "AutoGrab", false)
GetAutoGrab = GetAutoGrabFunc
SetAutoGrab = SetAutoGrabFunc
local GetFloatStealFunc, SetFloatSteal = CreateToggle(MainFrame, "Smart Float", 202, "SmartFloat", false)
GetFloatSteal = GetFloatStealFunc
local GetSpeedBoostFunc, SetSpeedBoost = CreateToggle(MainFrame, "Speed Boost", 242, "SpeedBoost", false)
GetSpeedBoost = GetSpeedBoostFunc
local GetHitboxExpFunc, SetHitboxExp = CreateToggle(MainFrame, "Hitbox Exp", 282, "HitboxExpander", false)
GetHitboxExp = GetHitboxExpFunc
local GetAutoBatFunc, SetAutoBat = CreateToggle(MainFrame, "Auto Bat", 322, "AutoBat", false)
GetAutoBat = GetAutoBatFunc
local GetUnwalkFunc, SetUnwalkFunc = CreateToggle(MainFrame, "Unwalk", 362, "Unwalk", false)
GetUnwalk = GetUnwalkFunc
SetUnwalk = SetUnwalkFunc
local GetTargetPlayerFunc, SetTargetPlayerFunc = CreateToggle(MainFrame, "Target Player", 402, "TargetPlayer", false)
GetTargetPlayer = GetTargetPlayerFunc
SetTargetPlayer = SetTargetPlayerFunc
local GetInfJumpFunc, SetInfJumpFunc = CreateToggle(MainFrame, "Infinite Jump", 442, "InfJump", false)
GetInfJump = GetInfJumpFunc
SetInfJump = SetInfJumpFunc
local GetXrayFunc, SetXrayFunc = CreateToggle(MainFrame, "XRay + Opt", 482, "Xray", false)
GetXray = GetXrayFunc
SetXray = SetXrayFunc
local GetTweenPanelFunc, SetTweenPanelFunc = CreateToggle(MainFrame, "Tween Panel", 522, "TweenPanel", false)
GetTweenPanel = GetTweenPanelFunc
SetTweenPanel = SetTweenPanelFunc

SpeedFrame = Instance.new("Frame")
SpeedFrame.Size = UDim2.new(0, 200 * ScaleFactor, 0, 70 * ScaleFactor)
SpeedFrame.Position = UDim2.new(1, -220 * ScaleFactor, 1, -90 * ScaleFactor)
SpeedFrame.BackgroundColor3 = Color3.fromRGB(12, 12, 12)
SpeedFrame.BorderSizePixel = 0
SpeedFrame.Visible = false
SpeedFrame.Active = true
SpeedFrame.Draggable = true
SpeedFrame.Parent = ScreenGui
Instance.new("UICorner", SpeedFrame).CornerRadius = UDim.new(0, 8 * ScaleFactor)
Instance.new("UIStroke", SpeedFrame).Color = Color3.fromRGB(138, 43, 226)

local SpeedTitle = Instance.new("TextLabel", SpeedFrame)
SpeedTitle.Size = UDim2.new(1, 0, 0, 20 * ScaleFactor)
SpeedTitle.Position = UDim2.new(0, 0, 0, 5 * ScaleFactor)
SpeedTitle.BackgroundTransparency = 1
SpeedTitle.Text = "Speed Boost"
SpeedTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
SpeedTitle.Font = Enum.Font.GothamBold
SpeedTitle.TextSize = 12 * ScaleFactor

local SpeedNormalLabel = Instance.new("TextLabel", SpeedFrame)
SpeedNormalLabel.Size = UDim2.new(0, 45 * ScaleFactor, 0, 20 * ScaleFactor)
SpeedNormalLabel.Position = UDim2.new(0, 10 * ScaleFactor, 0, 28 * ScaleFactor)
SpeedNormalLabel.BackgroundTransparency = 1
SpeedNormalLabel.Text = "Normal"
SpeedNormalLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
SpeedNormalLabel.Font = Enum.Font.Gotham
SpeedNormalLabel.TextSize = 10 * ScaleFactor
SpeedNormalLabel.TextXAlignment = Enum.TextXAlignment.Left

local SpeedNormalBox = Instance.new("TextBox", SpeedFrame)
SpeedNormalBox.Size = UDim2.new(0, 40 * ScaleFactor, 0, 18 * ScaleFactor)
SpeedNormalBox.Position = UDim2.new(0, 55 * ScaleFactor, 0, 29 * ScaleFactor)
SpeedNormalBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
SpeedNormalBox.Text = tostring(NormalSpeed)
SpeedNormalBox.TextColor3 = Color3.fromRGB(255, 255, 255)
SpeedNormalBox.Font = Enum.Font.Gotham
SpeedNormalBox.TextSize = 11 * ScaleFactor
SpeedNormalBox.ClearTextOnFocus = false
Instance.new("UICorner", SpeedNormalBox).CornerRadius = UDim.new(0, 4 * ScaleFactor)

local SpeedStealLabel = Instance.new("TextLabel", SpeedFrame)
SpeedStealLabel.Size = UDim2.new(0, 30 * ScaleFactor, 0, 20 * ScaleFactor)
SpeedStealLabel.Position = UDim2.new(0, 105 * ScaleFactor, 0, 28 * ScaleFactor)
SpeedStealLabel.BackgroundTransparency = 1
SpeedStealLabel.Text = "Steal"
SpeedStealLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
SpeedStealLabel.Font = Enum.Font.Gotham
SpeedStealLabel.TextSize = 10 * ScaleFactor
SpeedStealLabel.TextXAlignment = Enum.TextXAlignment.Left

local SpeedStealBox = Instance.new("TextBox", SpeedFrame)
SpeedStealBox.Size = UDim2.new(0, 40 * ScaleFactor, 0, 18 * ScaleFactor)
SpeedStealBox.Position = UDim2.new(0, 140 * ScaleFactor, 0, 29 * ScaleFactor)
SpeedStealBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
SpeedStealBox.Text = tostring(StealSpeed)
SpeedStealBox.TextColor3 = Color3.fromRGB(255, 255, 255)
SpeedStealBox.Font = Enum.Font.Gotham
SpeedStealBox.TextSize = 11 * ScaleFactor
SpeedStealBox.ClearTextOnFocus = false
Instance.new("UICorner", SpeedStealBox).CornerRadius = UDim.new(0, 4 * ScaleFactor)

SpeedStatusLabel = Instance.new("TextLabel", SpeedFrame)
SpeedStatusLabel.Size = UDim2.new(1, -20 * ScaleFactor, 0, 16 * ScaleFactor)
SpeedStatusLabel.Position = UDim2.new(0, 10 * ScaleFactor, 0, 50 * ScaleFactor)
SpeedStatusLabel.BackgroundTransparency = 1
SpeedStatusLabel.Text = "NORMAL - " .. tostring(NormalSpeed)
SpeedStatusLabel.TextColor3 = Color3.fromRGB(0, 200, 100)
SpeedStatusLabel.Font = Enum.Font.GothamBold
SpeedStatusLabel.TextSize = 10 * ScaleFactor
SpeedStatusLabel.TextXAlignment = Enum.TextXAlignment.Left

SpeedNormalBox.FocusLost:Connect(function()
    local num = tonumber(SpeedNormalBox.Text)
    if num and num > 0 then
        NormalSpeed = num
        SavedSettings.NormalSpeed = num
        SaveSettings(SavedSettings)
    else
        SpeedNormalBox.Text = tostring(NormalSpeed)
    end
end)

SpeedStealBox.FocusLost:Connect(function()
    local num = tonumber(SpeedStealBox.Text)
    if num and num > 0 then
        StealSpeed = num
        SavedSettings.StealSpeed = num
        SaveSettings(SavedSettings)
    else
        SpeedStealBox.Text = tostring(StealSpeed)
    end
end)

local function KillWalkFling()
    if FlingConnection then FlingConnection:Disconnect() FlingConnection = nil end
    if CollisionConnection then CollisionConnection:Disconnect() CollisionConnection = nil end
    WalkFlingRunning = false
end

local function StartWalkFling()
    if WalkFlingRunning then return end
    local character = LocalPlayer.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not root or not humanoid then return end
    WalkFlingRunning = true

    CollisionConnection = RunService.Stepped:Connect(function()
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                for _, part in ipairs(plr.Character:GetChildren()) do
                    if part:IsA("BasePart") then part.CanCollide = false end
                end
            end
        end
    end)

    FlingConnection = RunService.Heartbeat:Connect(function()
        character = LocalPlayer.Character
        root = character and character:FindFirstChild("HumanoidRootPart")
        humanoid = character and character:FindFirstChild("Humanoid")
        if not (character and character.Parent and root and root.Parent and humanoid) then return end
        local moveDir = humanoid.MoveDirection
        local currentVel = root.Velocity
        root.Velocity = Vector3.new(0, 10000, 0)
        RunService.RenderStepped:Wait()
        if character and character.Parent and root and root.Parent then
            if moveDir.Magnitude > 0.1 then
                root.Velocity = Vector3.new(moveDir.X * 60, currentVel.Y, moveDir.Z * 60)
            else
                root.Velocity = Vector3.new(0, currentVel.Y, 0)
            end
        end
    end)
end

local function shouldBlockState()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    local s = humanoid:GetState()
    if s == Enum.HumanoidStateType.Physics or s == Enum.HumanoidStateType.Ragdoll or s == Enum.HumanoidStateType.FallingDown or s == Enum.HumanoidStateType.GettingUp then 
        return true 
    end
    return false
end

local function enableControls()
    pcall(function()
        Controls:Enable()
    end)
end

local function cleanChar()
    local character = LocalPlayer.Character
    if not character then return end
    for _, desc in pairs(character:GetDescendants()) do
        if desc:IsA("BallSocketConstraint") or desc:IsA("NoCollisionConstraint") or desc:IsA("HingeConstraint") or (desc:IsA("Attachment") and (desc.Name == "A" or desc.Name == "B")) then
            pcall(function() desc:Destroy() end)
        elseif desc:IsA("BodyVelocity") or desc:IsA("BodyPosition") or desc:IsA("BodyGyro") then
            pcall(function() desc:Destroy() end)
        elseif desc:IsA("Motor6D") then
            pcall(function() desc.Enabled = true end)
        end
    end
end

local function EnableAntiRagdoll()
    if AntiRagdollActive then return end
    AntiRagdollActive = true
    
    local character = LocalPlayer.Character
    if not character then
        character = LocalPlayer.CharacterAdded:Wait()
    end
    local humanoid = character:WaitForChild("Humanoid", 10)
    if not humanoid then return end
    
    enableControls()
    
    local stateConn = humanoid.StateChanged:Connect(function()
        if not AntiRagdollActive then return end
        if shouldBlockState() then
            pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
            cleanChar()
            pcall(function() Workspace.CurrentCamera.CameraSubject = humanoid end)
            enableControls()
        end
    end)
    table.insert(AntiRagdollConnections, stateConn)
    
    local steppedConn = RunService.Stepped:Connect(function()
        if not AntiRagdollActive then return end
        
        character = LocalPlayer.Character
        if not character then return end
        
        humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        if shouldBlockState() then
            pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
            cleanChar()
        end
    end)
    table.insert(AntiRagdollConnections, steppedConn)
    
    local descConn = character.DescendantAdded:Connect(function()
        if not AntiRagdollActive then return end
        if shouldBlockState() then cleanChar() end
    end)
    table.insert(AntiRagdollConnections, descConn)
    
    pcall(function()
        local pkg = ReplicatedStorage:FindFirstChild("Packages")
        if pkg then
            local net = pkg:FindFirstChild("Net")
            if net then
                local ev = net:FindFirstChild("RE/CombatService/ApplyImpulse") or net:FindFirstChild("ApplyImpulse")
                if ev and ev:IsA("RemoteEvent") then
                    local impulseConn = ev.OnClientEvent:Connect(function()
                        if shouldBlockState() then
                            local hrp = character and character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                pcall(function() hrp.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
                            end
                        end
                    end)
                    table.insert(AntiRagdollConnections, impulseConn)
                end
            end
        end
    end)
    
    local charAddedConn = LocalPlayer.CharacterAdded:Connect(function(newChar)
        task.wait(0.5)
        character = newChar
        humanoid = newChar:WaitForChild("Humanoid", 10)
        if not humanoid then return end
        
        task.wait(0.1)
        enableControls()
        cleanChar()
    end)
    table.insert(AntiRagdollConnections, charAddedConn)
    
    enableControls()
    cleanChar()
end

local function DisableAntiRagdoll()
    AntiRagdollActive = false
    
    for _, conn in pairs(AntiRagdollConnections) do
        pcall(function() conn:Disconnect() end)
    end
    AntiRagdollConnections = {}
end

local function SetupJumpTracking()
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.StateChanged:Connect(function(old, new)
                if new == Enum.HumanoidStateType.Jumping then
                    IsJumping = true
                elseif new == Enum.HumanoidStateType.Landed or new == Enum.HumanoidStateType.Running then
                    IsJumping = false
                end
            end)
        end
    end
end

local function EnableAntiKnockback()
    if AntiKnockbackActive then return end
    AntiKnockbackActive = true
    
    SetupJumpTracking()
    
    pcall(function()
        local pkg = ReplicatedStorage:FindFirstChild("Packages")
        if pkg then
            local net = pkg:FindFirstChild("Net")
            if net then
                local ev = net:FindFirstChild("RE/CombatService/ApplyImpulse") or net:FindFirstChild("ApplyImpulse")
                if ev and ev:IsA("RemoteEvent") then
                    ev.OnClientEvent:Connect(function()
                        if not AntiKnockbackActive then return end
                        local char = LocalPlayer.Character
                        local hrp = char and char:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            task.wait()
                            local vel = hrp.AssemblyLinearVelocity
                            local clampedX = math.clamp(vel.X, -MaxHorizontalSpeed, MaxHorizontalSpeed)
                            local clampedY = math.clamp(vel.Y, -MaxVerticalKnockback, MaxVerticalKnockback)
                            local clampedZ = math.clamp(vel.Z, -MaxHorizontalSpeed, MaxHorizontalSpeed)
                            hrp.AssemblyLinearVelocity = Vector3.new(clampedX, clampedY, clampedZ)
                        end
                    end)
                end
            end
        end
    end)
    
    AntiKnockbackConnection = RunService.Heartbeat:Connect(function()
        if not AntiKnockbackActive then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if not hrp or not humanoid then return end
        
        local state = humanoid:GetState()
        local currentVel = hrp.AssemblyLinearVelocity
        
        if state == Enum.HumanoidStateType.Jumping then
            IsJumping = true
            lastVelocity = currentVel
            return
        end
        
        if state == Enum.HumanoidStateType.Landed or state == Enum.HumanoidStateType.Running then
            IsJumping = false
        end
        
        if getgenv().TweenPanelRunning then
            lastVelocity = currentVel
            return
        end
        
        if shouldBlockState() then
            cleanChar()
            
            local clampedX = math.clamp(currentVel.X, -MaxHorizontalSpeed, MaxHorizontalSpeed)
            local clampedY = math.clamp(currentVel.Y, -MaxVerticalKnockback, MaxVerticalKnockback)
            local clampedZ = math.clamp(currentVel.Z, -MaxHorizontalSpeed, MaxHorizontalSpeed)
            hrp.AssemblyLinearVelocity = Vector3.new(clampedX, clampedY, clampedZ)
            
            pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Running) end)
            lastVelocity = hrp.AssemblyLinearVelocity
            return
        end
        
        local newVel = currentVel
        local needsChange = false
        
        local horizontalVel = Vector3.new(currentVel.X, 0, currentVel.Z)
        if horizontalVel.Magnitude > MaxHorizontalSpeed then
            local dir = horizontalVel.Unit
            newVel = Vector3.new(dir.X * MaxHorizontalSpeed, newVel.Y, dir.Z * MaxHorizontalSpeed)
            needsChange = true
        end
        
        if not IsJumping and state ~= Enum.HumanoidStateType.Freefall then
            if currentVel.Y > MaxVerticalKnockback then
                newVel = Vector3.new(newVel.X, MaxVerticalKnockback, newVel.Z)
                needsChange = true
            end
        end
        
        if state == Enum.HumanoidStateType.Freefall and not IsJumping then
            local yChange = currentVel.Y - lastVelocity.Y
            if yChange > 40 then
                newVel = Vector3.new(newVel.X, math.min(currentVel.Y, MaxVerticalKnockback), newVel.Z)
                needsChange = true
            end
        end
        
        if needsChange then
            hrp.AssemblyLinearVelocity = newVel
        end
        
        lastVelocity = hrp.AssemblyLinearVelocity
    end)
end

local function DisableAntiKnockback()
    AntiKnockbackActive = false
    if AntiKnockbackConnection then AntiKnockbackConnection:Disconnect() AntiKnockbackConnection = nil end
end

local function GetNearestPlayerDistance(hrp)
    local minDist = math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local o = player.Character:FindFirstChild("HumanoidRootPart")
            if o then minDist = math.min(minDist, (hrp.Position - o.Position).Magnitude) end
        end
    end
    return minDist
end

local function StartFloat()
    if IsCurrentlyFloating then return end
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    IsCurrentlyFloating = true
    OriginalGroundY = GetRealGroundY(hrp)
    
    if FloatPlatform then FloatPlatform:Destroy() end
    FloatPlatform = Instance.new("Part")
    FloatPlatform.Size = Vector3.new(4, 0.5, 4)
    FloatPlatform.Anchored = true
    FloatPlatform.CanCollide = true
    FloatPlatform.Transparency = 1
    FloatPlatform.Name = "FloatPlatform"
    FloatPlatform.Parent = Workspace
    FloatPlatform.Position = Vector3.new(hrp.Position.X, hrp.Position.Y - 3, hrp.Position.Z)
    
    FloatConnection = RunService.Heartbeat:Connect(function(dt)
        if not IsCurrentlyFloating then return end
        if not FloatPlatform or not FloatPlatform.Parent then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local targetHeight = GetCurrentFloatHeight(hrp)
        local targetPlatformY = OriginalGroundY + targetHeight - 3
        local currentY = FloatPlatform.Position.Y
        local diff = targetPlatformY - currentY
        
        local moveSpeed = 40
        
        local newY
        if math.abs(diff) < 0.1 then
            newY = targetPlatformY
        else
            local step = math.sign(diff) * math.min(math.abs(diff), dt * moveSpeed)
            newY = currentY + step
        end
        
        FloatPlatform.Position = Vector3.new(hrp.Position.X, newY, hrp.Position.Z)
    end)
end

local function StopFloat()
    IsCurrentlyFloating = false
    OriginalGroundY = nil
    if FloatConnection then 
        FloatConnection:Disconnect() 
        FloatConnection = nil 
    end
    if FloatPlatform then 
        FloatPlatform:Destroy() 
        FloatPlatform = nil 
    end
end

local function UpdateHitboxExpander(enabled)
    if HitboxConnection then HitboxConnection:Disconnect() HitboxConnection = nil end
    if enabled then
        HitboxConnection = RunService.RenderStepped:Connect(function()
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.Size = Vector3.new(12, 12, 12)
                        hrp.Transparency = 0.4
                        hrp.Color = Color3.fromRGB(138, 43, 226)
                        hrp.Material = Enum.Material.SmoothPlastic
                        hrp.CanCollide = false
                    end
                end
            end
        end)
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Size = Vector3.new(2, 2, 1)
                    hrp.Transparency = 1
                    hrp.CanCollide = true
                end
            end
        end
    end
end

local function FindBatTool()
    local character = LocalPlayer.Character
    if not character then return nil, false end
    local eq = character:FindFirstChild("Bat")
    if eq and eq:IsA("Tool") then return eq, true end
    local bp = LocalPlayer:FindFirstChild("Backpack")
    if bp then
        local bat = bp:FindFirstChild("Bat")
        if bat and bat:IsA("Tool") then return bat, false end
    end
    return nil, false
end

local function EquipBatBySlot()
    local bp = LocalPlayer:FindFirstChild("Backpack")
    if not bp then return end
    local slot = 0
    for _, tool in ipairs(bp:GetChildren()) do
        if tool:IsA("Tool") then
            slot = slot + 1
            if tool.Name == "Bat" then break end
        end
    end
    if slot > 0 and slot <= 9 then
        local keys = {Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four, Enum.KeyCode.Five, Enum.KeyCode.Six, Enum.KeyCode.Seven, Enum.KeyCode.Eight, Enum.KeyCode.Nine}
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keys[slot], false, game)
            task.wait()
            VirtualInputManager:SendKeyEvent(false, keys[slot], false, game)
        end)
    end
end

local function SwingBat()
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        task.wait()
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    end)
end

task.spawn(function()
    while task.wait(BatSpamDelay) do
        if not AutoBatEnabled then continue end
        local bat, isEquipped = FindBatTool()
        if bat then
            if not isEquipped then EquipBatBySlot() else SwingBat() end
        end
    end
end)

task.spawn(function()
    while task.wait(0.05) do
        if not FloatStealEnabled then
            if IsCurrentlyFloating then StopFloat() end
            FloatStealStartTime = 0
            continue
        end
        
        local character = LocalPlayer.Character
        if not character then continue end
        local humanoid = character:FindFirstChild("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp then continue end
        
        local isStealing = humanoid.WalkSpeed <= 25
        local playerNearby = GetNearestPlayerDistance(hrp) <= SmartFloatRange
        
        if isStealing and FloatStealStartTime == 0 then
            FloatStealStartTime = tick()
        elseif not isStealing then
            FloatStealStartTime = 0
        end
        
        local delayPassed = FloatStealStartTime > 0 and (tick() - FloatStealStartTime) >= FloatStartDelay
        local shouldFloat = isStealing and playerNearby and delayPassed
        
        if shouldFloat then
            if IsCurrentlyFloating and FloatPlatform and FloatPlatform.Parent then
                local platformY = FloatPlatform.Position.Y
                local myY = hrp.Position.Y
                if myY < (platformY - 5) then
                    StopFloat()
                    task.wait(0.1)
                    StartFloat()
                end
            elseif not IsCurrentlyFloating then
                StartFloat()
            end
        else
            if IsCurrentlyFloating then
                StopFloat()
            end
        end
    end
end)

-- OLD Speed Boost for Steal (unchanged)
TrackConnection(RunService.Heartbeat:Connect(function()
    if not SpeedBoostEnabled then return end
    local character = LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid or humanoid.Health <= 0 then return end
    local state = humanoid:GetState()
    if state == Enum.HumanoidStateType.Physics or state == Enum.HumanoidStateType.Ragdoll or state == Enum.HumanoidStateType.FallingDown then return end
    local isStealing = humanoid.WalkSpeed <= 25
    local currentSpeed = isStealing and StealSpeed or NormalSpeed
    SpeedStatusLabel.Text = (isStealing and "STEALING - " or "NORMAL - ") .. tostring(currentSpeed)
    SpeedStatusLabel.TextColor3 = isStealing and Color3.fromRGB(255, 180, 50) or Color3.fromRGB(0, 200, 100)
    local moveDir = humanoid.MoveDirection
    if moveDir.Magnitude > 0.1 then
        local dir = moveDir.Unit
        local currentVel = hrp.AssemblyLinearVelocity
        local targetVel = Vector3.new(dir.X * currentSpeed, currentVel.Y, dir.Z * currentSpeed)
        local lerpAlpha = 1.0
        local smoothVel = currentVel:Lerp(targetVel, lerpAlpha)
        hrp.AssemblyLinearVelocity = smoothVel
    end
end))

local lastAntiRagdoll, lastAntiKnockback, lastWalkFling, lastAutoGrab = false, false, false, false
local lastFloatSteal, lastSpeedBoost, lastHitbox, lastAutoBat, lastUnwalk = false, false, false, false, false
local lastTargetPlayer, lastInfJump, lastXray, lastTweenPanel = false, false, false, false

TrackConnection(RunService.Heartbeat:Connect(function()
    local ar, ak, wf, ag = GetAntiRagdoll(), GetAntiKnockback(), GetWalkFling(), GetAutoGrab()
    local fs, sb, hb, ab, uw = GetFloatSteal(), GetSpeedBoost(), GetHitboxExp(), GetAutoBat(), GetUnwalk()
    local tp, ij, xr, tpanel = GetTargetPlayer(), GetInfJump(), GetXray(), GetTweenPanel()

    if ar ~= lastAntiRagdoll then
        if ar then EnableAntiRagdoll() else DisableAntiRagdoll() end
        lastAntiRagdoll = ar
    end
    if ak ~= lastAntiKnockback then
        if ak then EnableAntiKnockback() else DisableAntiKnockback() end
        lastAntiKnockback = ak
    end
    if wf ~= lastWalkFling then
        if wf then StartWalkFling() else KillWalkFling() end
        lastWalkFling = wf
    end
    if ag ~= lastAutoGrab then
        AutoGrabEnabled = ag
        if ag then
            pcall(function()
                loadstring(game:HttpGet(URLS.AutoGrab))()
            end)
        else
            if getgenv().SchmecktAutoGrab then
                getgenv().SchmecktAutoGrab.Disable()
            end
        end
        lastAutoGrab = ag
    end
    if fs ~= lastFloatSteal then
        FloatStealEnabled = fs
        if not fs then StopFloat() FloatStealStartTime = 0 end
        lastFloatSteal = fs
    end
    if sb ~= lastSpeedBoost then
        SpeedBoostEnabled = sb
        SpeedFrame.Visible = sb
        lastSpeedBoost = sb
    end
    if hb ~= lastHitbox then
        UpdateHitboxExpander(hb)
        lastHitbox = hb
    end
    if ab ~= lastAutoBat then
        AutoBatEnabled = ab
        lastAutoBat = ab
    end
    if uw ~= lastUnwalk then
        if uw then EnableUnwalk() else DisableUnwalk() end
        lastUnwalk = uw
    end
    if tp ~= lastTargetPlayer then
        TargetPlayerEnabled = tp
        if tp then StartTargetPlayer() else StopTargetPlayer() end
        lastTargetPlayer = tp
    end
    if ij ~= lastInfJump then
        InfJumpEnabled = ij
        if ij then EnableInfJump() else DisableInfJump() end
        lastInfJump = ij
    end
    if xr ~= lastXray then
        XrayEnabled = xr
        if xr then EnableXray() else DisableXray() end
        lastXray = xr
    end
    if tpanel ~= lastTweenPanel then
        if tpanel then
            loadstring(game:HttpGet("https://raw.githubusercontent.com/ima123-en/jaboilin123/refs/heads/main/a", true))()
        else
            pcall(function()
                if game.CoreGui:FindFirstChild("TweenPanel") then
                    game.CoreGui:FindFirstChild("TweenPanel"):Destroy()
                end
            end)
            -- Reset tween speed when panel is closed
            ResetTweenSpeed()
            TweenSpeedEnabled = false
        end
        lastTweenPanel = tpanel
    end
end))

local function FullCleanup()
    CleanupAllConnections()
    KillWalkFling()
    DisableAntiRagdoll()
    DisableAntiKnockback()
    DisableUnwalk()
    StopFloat()
    UpdateHitboxExpander(false)
    StopTargetPlayer()
    DisableInfJump()
    DisableXray()
    ResetTweenSpeed()
    if FloatPlatform then FloatPlatform:Destroy() FloatPlatform = nil end
    if getgenv().SchmecktAutoGrab then getgenv().SchmecktAutoGrab.Disable() end
    pcall(function()
        if game.CoreGui:FindFirstChild("TweenPanel") then
            game.CoreGui:FindFirstChild("TweenPanel"):Destroy()
        end
    end)
end

CloseButton.MouseButton1Click:Connect(function()
    FullCleanup()
    ScreenGui:Destroy()
end)

TrackConnection(LocalPlayer.CharacterAdded:Connect(function(char)
    StopFloat()
    FloatStealStartTime = 0
    OriginalGroundY = nil
    lastVelocity = Vector3.new(0, 0, 0)
    IsJumping = false
    ResetTweenSpeed()
    
    local humanoid = char:WaitForChild("Humanoid", 10)
    if humanoid then
        humanoid.StateChanged:Connect(function(old, new)
            if new == Enum.HumanoidStateType.Jumping then
                IsJumping = true
            elseif new == Enum.HumanoidStateType.Landed or new == Enum.HumanoidStateType.Running then
                IsJumping = false
            end
        end)
    end
    
    if UnwalkEnabled then
        task.wait(0.5)
        DisableAnimations()
    end
    if InfJumpEnabled then
        task.wait(0.5)
        EnableInfJump()
    end
    if TargetPlayerEnabled then
        task.wait(0.5)
        StartTargetPlayer()
    end
    if AntiRagdollActive then
        task.wait(0.5)
        EnableAntiRagdoll()
    end
end))
